4주차 : 2020.01.21 (화)
=============

### 책 4장
* 81P
  * 잘 설계된 서비스의 특징 : 단일 역량을 담당, 독립적으로 배포 가능, 교체 가능
* 84P
  * 서비스의 범위를 정하는 3가지 전략
    * 비즈니스 역량 또는 바운디드 컨텍스트에 따라 지정
    * 유스케이스에 따라 지정
    * 변동 가능성에 따라 지정
* 91P
  * 미리 서비스가 어떤 이벤트를 생성할지도 고려해야 함 -> 이벤트 기반 모델
* 102P
  * 유스케이스별로 서비스의 범위를 지정했다면 다른 서비스 행동을 조율(동기처리)하는 형태가 될 가능성이 큼
  * 조율과 이벤트 기반으로 처리하는 자율적 구성을 균형있게 선택해야 함
* 107P
  * 범위를 정하기 모호할 때
    * 큰 규모의 서비스로 시작하기
    * 향후 분배를 위한 준비
    * 제거와 이관

### 책 5장
* 122P
  * 자율적으로 구성된 사가 패턴
    * 자율성 증대
    * 검증, 상태 관리 어려움
    * 순환 의존성 유발
    * 실행 흐름 추적을 위한 모니터링 및 추적 기능 필수
* 125P
  * 조율된 사가 패턴
    * 로직이 조율자로 이동해 개별 서비스가 간단해지고 상태의 복잡도 줄어듬
    * 조율자가 너무 많은 로직을 가진다는 위험이 있음
    * 자율적이고 독립적인 동작과 거리가 멈
* 127P
  * 중첩된 사가 패턴
    * 로컬 트랜잭션과 다르게 사가는 격리가 없음
    * 사가가 진행 중에 연관된 요청이 들어왔을 때 중첩
    * 회로 차단하기 : 사가가 진행 중일 때는 새로운 사가를 막음, 가장 간단하지만 사용자 입장에서 좋지 않음
    * 잠그기 : 엔티티로의 접근을 제어하기 위해 락을 사용, 데드락 모니터링 및 타임아웃 등 필요
    * 인터럽트 : 동작 실행을 방해, 로직 진행 중 상태를 재확인, 복잡해지지만 데드락의 위험은 없음
* 129P
  * 일관성 적략
    * 보상 동작
    * 재시도
    * 무시
    * 재시작
    * 잠정적 동작 : 잠정적 동작을 수행한 후 나중에 확정 또는 취소
  * 이벤트 소싱
* 131P
  * 분산된 환경에서의 질의 (컴포지션 API)
    * 성능이 비효율적이고 기대 이하가 되는 경우
      * 상당한 데이터를 조인하는 경우
      * 여러 서비스 간의 집계와 분석을 하는 경우
      * 서비스의 DB가 지원하지 않는 경우
    * 동기식 호출이 필요하여 가용성에 영향을 받음
  * 효율적인 질의 구축 
    * 데이터 복제본
      * 이벤트 발생했을 때 내용 저장
      * 위험 : 복잡도 증가, 이벤트 스키마 변경 위험, 캐시 제거 어려움
      * 복제 데이터가 최신이 아닌 상황에 대비 필요
      * 가용성(락 강화, 트랜잭션 속도 저해)과 일관성(보상동작, 재시도에 의지) 중 선택 필요
    * 질의와 명령 분리 (CQRS 아키텍처)
      * 장점
        * 특정 질의를 위해 질의 모델을 최적화해 질의 성능을 개선하고 서비스 간 조인의 필요성 제거
        * 서비스 내 및 애플리케이션 수준 모두에서 관심사의 분리를 도움
    * CQRS의 어려운점
      * 궁극적인 일관성 고려해야 함
      * 복제 지연에 대비하는 전략
        * 낙관적 갱신 : UI에 먼저 반영하고 실제 처리 후 확정 및 롤백
        * 폴링 : UI가 변경한 내용이 반영될 때까지 폴링
        * 게시-구독 : 폴링 대신 웹소켓 채널 등으로 질의 모델의 이벤트 구독
    * 분석과 리포팅 : 이벤트를 별도 저장소에 저장

### 논의
* 프로젝트 환경
  * Google Cloud Platform
  * Kubernetes

### 숙제
* 책 6장
* Google Cloud Platform 계정 및 튜토리얼
