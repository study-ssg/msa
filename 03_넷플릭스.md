https://youtu.be/OczG5FQIcXw


# 1. 마이크로서비스란


![img](https://solutiondots.com/wp-content/uploads/2018/04/Microservices-Architecture-Vs-Monolithic-Application.jpg)

### Monolithic Application
모놀리틱이라고 하는 하나의 큰 덩어리로 움직이는 애플리케이션을 운영하면서 여러 가지 문제가 발생한다. 하나의 배포시스템에 모든 개발자의 작업이 연결되어 있기 때문에 문제가 발생하면 원인을 찾기가 쉽지 않다. 데이터베이스가 다운되면 모든 서비스에 영향을 끼치며 트래픽이 몰리는 이벤트가 생길 땐 부하 방지를 위해 좋은 하드웨어의 장비를 추가 구매한다. 무엇보다 애플리케이션 하나에 모든 서비스가 연결되어 있기에 작은 변경에도 다른 서비스에 영향을 주는 상황이 생긴다.

### Microservices Architecture
작은 서비스들의 집합으로 각 서비스는 HTTP 통신의 API를 통해 연결된다.

### 조쉬 에반스가 생각하는 마이크로서비스의 특징

1. 위험을 잘게 쪼갠다: 모듈화 및 캡슐화
2. 수평적 확장: 여러 개의 작은 부분으로 분리해서 분산 처리
3. 가상화 기반 환경: 자동화, 유연성



# 2. 넷플릭스의 마이크로서비스 도입 도전과 문제 해결

### ● Dependency: 의존성

서비스가 다른 서비스를 호출할 때 네트워크, 트래픽 문제 등 다양한 에러가 발생할 수 있고 각 서비스 간 의존성이 높은 경우 연속적으로 장애가 발생할 수 있다. 넷플릭스는 이런 의존성의 문제를 해결하기 위해 Hystrix라는 도구를 만들어 사용했다. 타임아웃이나 재시도 같은 동작을 구조적으로 다루며 fallback을 활용하여 서비스 B에 오류가 있더라도 사전에 지정된 응답을 전달하거나 전달받아 다른 서비스에 영향을 주지 않도록 한다.

또한 해당 문제를 테스트하기 위해 FIT(장애 주입 테스트 프레임워크)를 만들어 서비스에 발생할 문제를 시뮬레이션했다. 시뮬레이션을 할 서비스의 범위 산정도 중요한 문제였다. 테스트의 대상이 되는 기능의 동작을 위해 필요한 서비스들을 그룹화하여 FIT 레시피를 만든다. 예를 들면 '넷플릭스에 접근해서 영화를 선택하고 플레이 버튼을 누르면 영화가 재생된다'는 프로세스에 필수적인 서비스들만 그룹화하는 것이다. 이를 통해 각 서비스 간 연결에 의존성을 끊어도 장애가 나는지 테스트를 진행했다.

클라이언트 라이브러리의 구성 문제도 중요한 이슈 중 하나인데 라이브러리를 구성할 경우 공통된 로직을 하나로 통합하는데 이점을 가지지만 다른 의존성이 있는 라이브러리와 충돌하거나 빌드가 깨지는 등의 문제가 발생할 수 있다. 즉, API 게이트웨이에 또 다른 모놀리틱 형태가 발생할 수 있다. 여전히 정답은 없지만 라이브러리를 더 간단한 규모로 만드는 걸 추천한다.

데이터 관리를 위해 CAP 이론(네트워크가 분리된 환경에서는 가용성과 일관성 중 반드시 하나를 선택해야 한다는 이론)을 어떻게 구현할까에 대한 고민부터 시작했다. 만약 A, B, C 각각 다른 네트워크에 존재하는 DB가 있다고 가정했을 때, 한 개 이상의 데이터베이스에 접근이 안되면 어떻게 할 것인가? 1) 실패를 그대로 받아들이고 에러를 리턴할 것인지, 2) 일단 되는 곳에 먼저 저장하고 나중에 정상화되면 복제할 것인지 중에 넷플릭스는 후자를 선택했다. 최종 일관성을 추구하는 형태다. 이는 아파치 카산드라를 통해 구현했다. 클라이언트가 하나의 노드에만 쓰기를 수행해도 이 데이터를 모든 노드에 복제해주는 형태다.

인프라 구축에 있어서 AWS를 사용하는 넷플릭스는 멀티 리전 방식을 구현했다.

##### @ 요약

서킷 브레이커, fallback, 카오스 적용을 고려하라.
클라이언트를 단순화하고 최종 일관성을 적용하라.


### ● Scale: 확장

Auto Scaling은 마이크로서비스에서 굉장히 중요한 개념 중에 하나다. stateless sevice의 경우 서버의 문제가 서비스의 문제는 아니기 때문에 A라는 서버에 장애가 난 경우, 고객이 동일한 서버에 접근할 필요가 없다면 오토스케일링을 통해 서비스는 정상 동작하도록 구현한다. 넷플릭스에선 Chaos Monkey를 도입했고 이후 오토스케일링이 잘 동작하는지 걱정하는 일은 없었다고 한다.

한편 데이터베이스나 캐시와 같은 stateful service의 경우 하나의 애플리케이션에 모두 관리하는 건 위험하다. 해당 애플리케이션에 장애가 발생했을 경우 다시 복구하는데 큰 어려움이 있고 꽤나 시간이 걸리기 때문이다. 사람에게 폐가 두 개이듯 stateful service도 복제의 과정이 필요하다. 넷플릭스는 EVCache를 사용하여 캐시를 관리하는데 샤딩이 지원되어 데이터 쓰기가 발생할 때마다 여러 개의 영역에 복제된다.

넷플릭스는 하이브리드 방식으로 EVCache를 적용했는데 이는 막대한 트래픽을 처리하던 EVCache 계층 전체가 완전히 다운되는 경우, 데이터베이스는 결국 그 트래픽을 버티지 못하고 전체 서비스가 내려갈 것이기 때문이다. 이를 위해 1) 배치 작업을 위한 캐시 요청과 실시간 캐시 요청을 분리하였고 2) 하나의 요청 안에서 발생하는 캐시 참조는 한 번만 발생하도록 했다.

##### @ 요약

오토스케일링을 꼭 쓰자.
단일 장애 포인트를 없애라.
업무를 분리하라.
실패에 기반해 디자인하라.
부하 상태에서 카오스를 만들어 예상 동작을 확인하라.


### ● Variance: 다양성

변경이 일어나는 경우는 다양하다. 시간이 지나 목적에 의해 자연스럽게 변화되는 케이스들을 넷플릭스에서는 지속적으로 학습하고 자동화하는 방식을 도입했다. 최근에 뜨고 있는 다양성의 문제 중에는 Polyglot(여러 언어를 쓰는 케이스), 컨테이너가 있다. 사람들은 마이크로서비스에 이 새로운 기술들을 적용하려고 한다.

이런 다양성을 유지하는 데는 비용이 든다. Docker 컨테이너를 사용하면서 발생하는 비용, 모니터링을 위한 비용 등이다. 모놀리틱 애플리케이션을 하나의 포장도로라고 한다면 마이크로서비스에 다양성을 입히면서는 여러 종류의 포장도로로 발전하는 셈이다. 그렇기에 중앙화 된 관리 및 자원을 제공하는 팀에서는 다양성의 문제를 해결하는 게 큰 도전이다. 넷플릭스는 엔지니어들이 아키텍처를 선택할 때 다양한 정보를 기반으로 올바른 선택을 하도록 도왔으며 지원 범위를 제한하거나 재사용 가능한 솔루션을 찾아 비용 문제를 해결했다.

##### @ 요약

최대한 자동화하라.
다양성을 구현하고 유지하는 비용을 이해하라.
중앙 관리 조직은 지원에 우선순위를 고려하라.


### ● Change: 변화

어떻게 가능한 빠르게, 그리고 장애가 나지 않을 거란 자신감을 갖고 변경을 적용할 수 있는지에 대한 해답으로 넷플릭스는 Spinnaker라는 새로운 배포 플랫폼을 만들었다. 글로벌 클라우드 관리 플랫폼이며 자동화된 배포를 수행하는 Spinnaker는 다양한 경험을 바탕으로 발생하는 변경사항을 프로덕션에 적절히 배포할 수 있도록 디자인된 도구이다. 예를 들어 새로운 버전의 애플리케이션이 배포될 때 라이브 시스템에서 유입되는 트래픽의 일부를 자동으로 새 버전에 흐르게 하여 기존 코드와 새로운 코드를 비교할 수 있다.

Spinnaker
www.spinnaker.io 

##### @ 요약

자동화된 배포와 경험을 지속적으로 반영하도록 하라.


# 3. 조직과 아키텍처

넷플릭스는 '일렉트로닉 딜리버리'라 불리는 기능(오늘날의 스트리밍 서비스와 유사한 기능)을 제공했는데 서버와 클라이언트 모두 하나의 조직에서 일했다. 시스템의 디자인은 XML 기반이며 그 안에 독자적으로 만들어진 응답을 제공하고 배포 주기가 꽤 긴 펌웨어 버전 릴리즈를 진행했다. 이후 넷플릭스 API라는 기능이 생기게 되며 이는 넷플릭스 UI를 혁신하는 촉매가 되었다. JSON 스키마, HTTP 응답 코드 기반, REST API, OAuth 보안 모델 등 현대의 API 아키텍처의 모습을 띄었는데, 문제는 기존 일렉트로닉 딜리버리 서비스와 다른 형태로 구성된 엣지 서비스라는 점이었다.

##### @ Conway's Law

1. 시스템은 시스템을 디자인하는 조직의 커뮤니케이션 구조를 반영한다.
2. 소프트웨어는 그걸 만든 조직의 구조를 닮는다.
3. 컴파일러는 만드는 조직이 4개면 4개의 단계를 가지는 컴파일러가 만들어진다.

조쉬 에반스는 일렉트로닉 딜리버리, API를 운영하는 팀이 달랐고 이 아키텍처가 문제가 된 이유는 해법이 아닌 조직을 우선했기 때문이라고 판단했다. 이후 두 개의 서비스를 통합했고 장기적으로 높은 수준의 성능과 개선 속도를 제공했으며 조직을 리팩터링 했다. 해법을 먼저 찾고 팀은 그다음이다.
